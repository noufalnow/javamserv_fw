/*package com.cboard.rental.tenants.clients;

import feign.Response;
import feign.codec.ErrorDecoder;
import org.springframework.stereotype.Component;

import com.cboard.rental.tenants.config.ResourceNotFoundException;

@Component
public class CustomFeignErrorDecoder implements ErrorDecoder {

    @Override
    public Exception decode(String methodKey, Response response) {
        switch (response.status()) {
            case 400:
                return new IllegalArgumentException("Bad Request");
            case 404:
                // Extracting resource information from methodKey and response if needed
                String resourceName = "Property"; // Assuming it's a property for now; can be extracted dynamically if needed
                String message = "Resource not found";
                Object resourceId = extractResourceIdFromMethodKey(methodKey); // Assuming a method to extract resource ID

                return new ResourceNotFoundException(message, resourceName, resourceId);
            case 500:
                return new RuntimeException("Internal Server Error - Property service encountered an error");
            default:
                return new Exception("Generic error");
        }
    }

    private Object extractResourceIdFromMethodKey(String methodKey) {
        // Implement logic to extract the resource ID from the methodKey if possible.
        // This is a placeholder function. You may parse methodKey or create a custom mapping.
        return null; // Replace with actual ID extraction logic if applicable
    }
}
*/
package com.cboard.rental.tenants.clients;

import feign.RequestInterceptor;
import feign.RequestTemplate;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;
import jakarta.servlet.http.HttpServletRequest;

@Configuration
public class FeignConfig {

    @Bean
    public RequestInterceptor requestInterceptor() {
        return requestTemplate -> {
            try {
                // Retrieve the current HTTP request
                ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
                if (attributes != null) {
                    HttpServletRequest request = attributes.getRequest();
                    String authHeader = request.getHeader("Authorization");

                    // Add the token to the outgoing Feign request if it exists
                    if (authHeader != null) {
                        requestTemplate.header("Authorization", authHeader);
                    }
                }
            } catch (Exception e) {
                // Log the exception to understand what went wrong, if any
                System.err.println("Failed to set Authorization header in Feign request: " + e.getMessage());
            }
        };
    }
}
package com.cboard.rental.tenants.clients;

import com.cboard.rental.tenants.dto.DuePaymentEvent;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

@FeignClient(name = "messaging-service", url = "http://localhost:8094", configuration = FeignConfig.class)
public interface MessagingServiceClient {
    @PostMapping("/api/v1/due-payments")
    void sendDuePaymentEvent(@RequestBody DuePaymentEvent event);
}
package com.cboard.rental.tenants.clients;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@FeignClient(name = "property-service", configuration = FeignConfig.class)
public interface PropertyServiceClient {
    @GetMapping("/properties/{propertyId}/exists")
    Boolean doesPropertyExist(@PathVariable("propertyId") Long propertyId);
}

package com.cboard.rental.tenants.config;

import ch.qos.logback.classic.pattern.ThrowableProxyConverter;
import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.classic.spi.ThrowableProxy;

public class CustomExceptionConverter extends ThrowableProxyConverter {
   
	protected void render(ThrowableProxy tp, ILoggingEvent event, StringBuilder builder) {
	    StackTraceElement[] stackTrace = tp.getThrowable().getStackTrace();
	    
	    for (StackTraceElement element : stackTrace) {
	        String className = element.getClassName();
	        // Exclude Spring, Hibernate, and JDK-related stack traces
	        if (className.startsWith("com.example.tenant_service") 
	                || className.startsWith("java.base")) {
	            builder.append(element.toString()).append(System.lineSeparator());
	        }
	    }
	}


}

package com.cboard.rental.tenants.config;

import java.util.Map;

public class CustomValidationException extends RuntimeException {

    private final Map<String, String> errors;

    public CustomValidationException(Map<String, String> errors) {
        super("Validation failed with errors: " + errors.toString());
        this.errors = errors;
    }

    public Map<String, String> getErrors() {
        return errors;
    }
}

package com.cboard.rental.tenants.config;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.ConstraintViolationException;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
@Order(Ordered.HIGHEST_PRECEDENCE)
public class GlobalExceptionHandler {

    private static final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleResourceNotFoundException(ResourceNotFoundException ex) {
        log.error("Resource not found: {}", ex.getMessage(), ex);
        ErrorResponse errorResponse = new ErrorResponse(
            HttpStatus.NOT_FOUND.value(),
            ex.getMessage(),
            "Resource Not Found",
            "ERR404", // Example error code
            ex.getResourceName(),
            ex.getResourceId()
        );
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
    }

    @ExceptionHandler(ConstraintViolationException.class)
    public ResponseEntity<ValidationErrorResponse> handleConstraintViolationException(ConstraintViolationException ex) {
        log.error("Validation failed: {}", ex.getMessage(), ex);
        Map<String, String> errors = new HashMap<>();
        for (ConstraintViolation<?> violation : ex.getConstraintViolations()) {
            errors.put(violation.getPropertyPath().toString(), violation.getMessage());
        }
        ValidationErrorResponse errorResponse = new ValidationErrorResponse(
            HttpStatus.BAD_REQUEST.value(),
            "Validation failed",
            errors
        );
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ValidationErrorResponse> handleValidationException(MethodArgumentNotValidException ex) {
        log.error("Method argument validation failed: {}", ex.getMessage(), ex);
        Map<String, String> errors = new HashMap<>();
        for (FieldError error : ex.getBindingResult().getFieldErrors()) {
            errors.put(error.getField(), error.getDefaultMessage() + " (rejected value: " + error.getRejectedValue() + ")");
        }
        ValidationErrorResponse errorResponse = new ValidationErrorResponse(
            HttpStatus.BAD_REQUEST.value(),
            "Validation failed",
            errors
        );
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
    }

    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorResponse> handleDataIntegrityViolationException(DataIntegrityViolationException ex) {
        String rootCauseMessage = ex.getRootCause() != null ? ex.getRootCause().getMessage() : "Unknown error";
        log.error("Data integrity violation: {}", rootCauseMessage, ex);
        ErrorResponse errorResponse = new ErrorResponse(
            HttpStatus.CONFLICT.value(),
            "Data integrity violation: " + rootCauseMessage,
            "Data Integrity Violation",
            "ERR001", // Example error code
            null,
            null
        );
        return ResponseEntity.status(HttpStatus.CONFLICT).body(errorResponse);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneralException(Exception ex) {
        log.error("An unexpected error occurred: {}", ex.getMessage(), ex);
        ErrorResponse errorResponse = new ErrorResponse(
            HttpStatus.INTERNAL_SERVER_ERROR.value(),
            "An unexpected error occurred",
            "Unexpected Error",
            "ERR500", // Example error code
            ex.getMessage(),
            null
        );
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
    }

    // ErrorResponse class with a timestamp and error code
    public static class ErrorResponse {
        private int status;
        private String message;
        private String errorType;
        private String errorCode;
        private String resource;
        private Object resourceId;
        private LocalDateTime timestamp;

        public ErrorResponse(int status, String message, String errorType, String errorCode, String resource, Object resourceId) {
            this.status = status;
            this.message = message + " - Error occurred"; // Updated for clarity
            this.errorType = errorType;
            this.errorCode = errorCode;
            this.resource = resource;
            this.resourceId = resourceId;
            this.timestamp = LocalDateTime.now(); // Set current time for errors
        }

        // Getters and setters
        public int getStatus() {
            return status;
        }

        public void setStatus(int status) {
            this.status = status;
        }

        public String getMessage() {
            return message;
        }

        public void setMessage(String message) {
            this.message = message;
        }

        public String getErrorType() {
            return errorType;
        }

        public void setErrorType(String errorType) {
            this.errorType = errorType;
        }

        public String getErrorCode() {
            return errorCode;
        }

        public void setErrorCode(String errorCode) {
            this.errorCode = errorCode;
        }

        public String getResource() {
            return resource;
        }

        public void setResource(String resource) {
            this.resource = resource;
        }

        public Object getResourceId() {
            return resourceId;
        }

        public void setResourceId(Object resourceId) {
            this.resourceId = resourceId;
        }

        public LocalDateTime getTimestamp() {
            return timestamp;
        }

        public void setTimestamp(LocalDateTime timestamp) {
            this.timestamp = timestamp;
        }
    }

    // ValidationErrorResponse class with validation errors
    public static class ValidationErrorResponse extends ErrorResponse {
        private Map<String, String> validationErrors;

        public ValidationErrorResponse(int status, String message, Map<String, String> validationErrors) {
            super(status, message, "Validation Error", "ERR400", null, null);
            this.validationErrors = validationErrors;
        }

        public Map<String, String> getValidationErrors() {
            return validationErrors;
        }

        public void setValidationErrors(Map<String, String> validationErrors) {
            this.validationErrors = validationErrors;
        }
    }
}package com.cboard.rental.tenants.config;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    @Autowired
    private JWTService jwtService;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        String authHeader = request.getHeader("Authorization");
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            String jwt = authHeader.substring(7);
            String username = jwtService.extractUsername(jwt);

            if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
                UserDetails userDetails = jwtService.extractUserDetails(jwt);

                if (jwtService.validateToken(jwt, userDetails)) {
                    var authToken = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                    authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                    SecurityContextHolder.getContext().setAuthentication(authToken);
                }
            }
        }
        filterChain.doFilter(request, response);
    }
}
package com.cboard.rental.tenants.config;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

import java.util.Date;
import java.util.List;
import java.util.function.Function;

@Service
public class JWTService {

    @Value("${jwt.secret}")
    private String SECRET_KEY;

    // Extract Username
    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    // Extract Claim
    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    // Validate Token
    public boolean validateToken(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
    }

    // Check if Token is Expired
    /*private boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }*/

    // Extract Expiration Date
    /*public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }*/

    // Extract All Claims
    private Claims extractAllClaims(String token) {
        try {
            return Jwts.parser()
                       .setSigningKey(SECRET_KEY.getBytes())
                       .parseClaimsJws(token)
                       .getBody();
        } catch (Exception e) {
            // Log or handle exception as needed
            throw new IllegalArgumentException("Invalid JWT Token", e);
        }
    }

    public UserDetails extractUserDetails(String token) {
        String username = extractUsername(token);
        List<String> roles = extractClaim(token, claims -> claims.get("roles", List.class));

        return User.builder()
                .username(username)
                .password("") // Password is not stored in JWT
                .roles(roles.stream()
                    .map(role -> role.replace("ROLE_", "")) // Ensure roles match Spring format
                    .toArray(String[]::new)) // Convert list to array
                .build();
    }

    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration); // This will now use extractAllClaims
    }

    public boolean isTokenExpired(String token) {
        Date expiration = extractClaim(token, Claims::getExpiration);
        // If expiration is null, assume the token does not expire
        return expiration != null && expiration.before(new Date());
    }
}
package com.cboard.rental.tenants.config;

import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .addSecurityItem(new SecurityRequirement().addList("bearerAuth"))
                .components(new Components()
                        .addSecuritySchemes("bearerAuth",
                                new SecurityScheme()
                                        .type(SecurityScheme.Type.HTTP)
                                        .scheme("bearer")
                                        .bearerFormat("JWT")))
                .info(new Info()
                        .title("Property Service API")
                        .version("1.0")
                        .description("API documentation for Property Service"));
    }
}
package com.cboard.rental.tenants.config;

public class ResourceNotFoundException extends RuntimeException {
    private String resourceName;
    private Object resourceId;

    // Existing constructor
    public ResourceNotFoundException(String message, String resourceName, Object resourceId) {
        super(message);
        this.resourceName = resourceName;
        this.resourceId = resourceId;
    }

    // New constructor for convenience
    public ResourceNotFoundException(String resourceName, Object resourceId) {
        super("Resource not found");
        this.resourceName = resourceName;
        this.resourceId = resourceId;
    }

    // Getters and setters
    public String getResourceName() {
        return resourceName;
    }

    public Object getResourceId() {
        return resourceId;
    }
}
package com.cboard.rental.tenants.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

import com.cboard.rental.tenants.config.JwtAuthenticationFilter;

@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class TenantsServiceSecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    public TenantsServiceSecurityConfig(JwtAuthenticationFilter jwtAuthenticationFilter) {
        this.jwtAuthenticationFilter = jwtAuthenticationFilter;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .authorizeRequests()
                .requestMatchers("/v3/api-docs/**", "/swagger-ui.html", "/swagger-ui/**").permitAll() // Permit Swagger
                .requestMatchers("/property/**").hasRole("ADMIN") // Protect property endpoints for ADMIN role
                .anyRequest().authenticated()
            .and()
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class); // Add JWT filter

        return http.build();
    }
}
package com.cboard.rental.tenants.controller;

import com.cboard.rental.tenants.dto.ContractDTO;
import com.cboard.rental.tenants.service.ContractService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/contracts")
public class ContractController {

    private static final Logger logger = LoggerFactory.getLogger(ContractController.class);

    @Autowired
    private ContractService contractService;

    @PostMapping
    @PreAuthorize("hasAnyRole('ADMIN', 'LANDLORD')")
    public ResponseEntity<ContractDTO> createContract(@RequestBody ContractDTO contractDTO) {
        logger.info("Received ContractDTO for creation: {}", contractDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(contractService.createContract(contractDTO));
    }

    @GetMapping
    @PreAuthorize("hasAnyRole('ADMIN', 'LANDLORD')")
    public ResponseEntity<List<ContractDTO>> getAllContracts(
            @RequestParam(required = false) Long tenantId,
            @RequestParam(required = false) Long propertyId) {
        return ResponseEntity.ok(contractService.getAllContracts(tenantId, propertyId));
    }


    @GetMapping("/{id}")
    @PreAuthorize("hasAnyRole('ADMIN', 'LANDLORD')")
    public ResponseEntity<ContractDTO> getContractById(@PathVariable Long id) {
        return ResponseEntity.ok(contractService.getContractById(id));
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasAnyRole('ADMIN', 'LANDLORD')")
    public ResponseEntity<ContractDTO> updateContract(@PathVariable Long id, @RequestBody ContractDTO contractDTO) {
        logger.info("Received ContractDTO for update: {}", contractDTO);
        return ResponseEntity.ok(contractService.updateContract(id, contractDTO));
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasAnyRole('ADMIN', 'LANDLORD')")
    public ResponseEntity<Void> deleteContract(@PathVariable Long id) {
        contractService.deleteContract(id);
        return ResponseEntity.noContent().build();
    }
}
package com.cboard.rental.tenants.controller;

import com.cboard.rental.tenants.scheduler.DuePaymentScheduler;

import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/v1/scheduler")
public class DuePaymentController {

    private final DuePaymentScheduler duePaymentScheduler;

    public DuePaymentController(DuePaymentScheduler duePaymentScheduler) {
        this.duePaymentScheduler = duePaymentScheduler;
    }

    @PreAuthorize("hasAnyRole('ADMIN', 'LANDLORD')")
    @GetMapping("/publish-due-payments")
    public String triggerDuePayments() {
        duePaymentScheduler.publishDuePayments();
        return "Due payments published successfully";
    }
}
package com.cboard.rental.tenants.controller;

import com.cboard.rental.tenants.dto.PaymentScheduleDTO;
import com.cboard.rental.tenants.service.PaymentScheduleService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/payment-schedules")
public class PaymentScheduleController {

    private final PaymentScheduleService service;

    @Autowired
    public PaymentScheduleController(PaymentScheduleService service) {
        this.service = service;
    }

    @PostMapping
    @PreAuthorize("hasAnyRole('ADMIN', 'LANDLORD')")
    /*public ResponseEntity<PaymentScheduleDTO> createPaymentSchedule(@Valid @RequestBody PaymentScheduleDTO dto) {
        PaymentScheduleDTO createdPaymentSchedule = service.createPaymentSchedule(dto);
        return ResponseEntity.ok(createdPaymentSchedule);
    }
    */
    
    public ResponseEntity<List<PaymentScheduleDTO>> createPaymentSchedules(@Valid @RequestBody List<PaymentScheduleDTO> dtos) {
        List<PaymentScheduleDTO> createdSchedules = dtos.stream()
            .map(service::createPaymentSchedule)
            .collect(Collectors.toList());
        return ResponseEntity.ok(createdSchedules);
    }
     
    

    @GetMapping("/{id}")
    @PreAuthorize("hasAnyRole('ADMIN', 'LANDLORD')")
    public ResponseEntity<PaymentScheduleDTO> getPaymentScheduleById(@PathVariable Long id) {
        PaymentScheduleDTO paymentSchedule = service.getPaymentScheduleById(id);
        return ResponseEntity.ok(paymentSchedule);
    }

    @GetMapping
    @PreAuthorize("hasAnyRole('ADMIN', 'LANDLORD')")
    public ResponseEntity<List<PaymentScheduleDTO>> getAllPaymentSchedules() {
        List<PaymentScheduleDTO> paymentSchedules = service.getAllPaymentSchedules();
        return ResponseEntity.ok(paymentSchedules);
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasAnyRole('ADMIN', 'LANDLORD')")
    public ResponseEntity<PaymentScheduleDTO> updatePaymentSchedule(@PathVariable Long id, @Valid @RequestBody PaymentScheduleDTO dto) {
        PaymentScheduleDTO updatedPaymentSchedule = service.updatePaymentSchedule(id, dto);
        return ResponseEntity.ok(updatedPaymentSchedule);
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasAnyRole('ADMIN', 'LANDLORD')")
    public ResponseEntity<Void> deletePaymentSchedule(@PathVariable Long id) {
        service.deletePaymentSchedule(id);
        return ResponseEntity.noContent().build();
    }
}

package com.cboard.rental.tenants.controller;

import java.util.List;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import com.cboard.rental.tenants.dto.TenantsDTO;
import com.cboard.rental.tenants.service.TenantsService;

@RestController
@RequestMapping("/tenants")
public class TenantsController {
    
    private static final Logger logger = LoggerFactory.getLogger(TenantsController.class);

    @Autowired
    private TenantsService tenantsService;

    @PostMapping
    @PreAuthorize("hasAnyRole('ADMIN', 'LANDLORD')")
    public ResponseEntity<TenantsDTO> createTenant(@RequestBody TenantsDTO tenantsDTO) {
        logger.info("Received TenantsDTO for creation: {}", tenantsDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(tenantsService.createTenant(tenantsDTO));
    }

    @GetMapping
    @PreAuthorize("hasAnyRole('ADMIN', 'LANDLORD')")
    public ResponseEntity<List<TenantsDTO>> getAllTenants() {
        return ResponseEntity.ok(tenantsService.getAllTenants());
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasAnyRole('ADMIN', 'LANDLORD')")
    public ResponseEntity<TenantsDTO> getTenantById(@PathVariable Long id) {
        return ResponseEntity.ok(tenantsService.getTenantById(id));
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasAnyRole('ADMIN', 'LANDLORD')")
    public ResponseEntity<TenantsDTO> updateTenant(@PathVariable Long id, @RequestBody TenantsDTO tenantsDTO) {
        logger.info("Received TenantsDTO for update: {}", tenantsDTO);
        return ResponseEntity.ok(tenantsService.updateTenant(id, tenantsDTO));
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasAnyRole('ADMIN', 'LANDLORD')")
    public ResponseEntity<Void> deleteTenant(@PathVariable Long id) {
        tenantsService.deleteTenant(id);
        return ResponseEntity.noContent().build();
    }
}
package com.cboard.rental.tenants.dto;

import lombok.Data;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Data
public class ContractDTO {

    private Long id;

    @NotNull(message = "Tenant ID is required")
    private Long tenantId;

    @NotNull(message = "Property ID is required")
    private Long propertyId;

    @NotNull(message = "Start date is required")
    private LocalDate startDate;

    @NotNull(message = "End date is required")
    private LocalDate endDate;

    @NotNull(message = "Monthly rent is required")
    @DecimalMin(value = "0.0", inclusive = false, message = "Monthly rent must be greater than zero")
    private BigDecimal monthlyRent;

    @NotNull(message = "Deposit amount is required")
    @DecimalMin(value = "0.0", inclusive = false, message = "Deposit amount must be greater than zero")
    private BigDecimal depositAmount;

    @Size(max = 50, message = "Payment terms cannot exceed 50 characters")
    private String paymentTerms;

    @NotBlank(message = "Contract status is required")
    @Size(max = 20, message = "Contract status cannot exceed 20 characters")
    private String contractStatus;

    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
package com.cboard.rental.tenants.dto;

import java.math.BigDecimal;
import java.time.LocalDate;

public class DuePaymentEvent {
    private Long tenantId;
    private Long contractId;
    private BigDecimal amount;
    private LocalDate scheduledDate;

    // Constructors, Getters, and Setters
    public DuePaymentEvent(Long tenantId, Long contractId, BigDecimal amount, LocalDate scheduledDate) {
        this.tenantId = tenantId;
        this.contractId = contractId;
        this.amount = amount;
        this.scheduledDate = scheduledDate;
    }

    public Long getTenantId() { return tenantId; }
    public Long getContractId() { return contractId; }
    public BigDecimal getAmount() { return amount; }
    public LocalDate getScheduledDate() { return scheduledDate; }
}package com.cboard.rental.tenants.dto;

import lombok.Data;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;


@Data
public class PaymentScheduleDTO {

    private Long id;

    @NotNull(message = "Tenant ID is required")
    private Long tenantId;

    @NotNull(message = "Contract ID is required")
    private Long contractId;

    @NotNull(message = "Property ID is required")
    private Long propertyId;

    @NotNull(message = "Amount is required")
    @DecimalMin(value = "0.0", inclusive = false, message = "Amount must be greater than zero")
    private BigDecimal amount;

    private Short bankId;

    @Size(max = 20, message = "Cheque number cannot exceed 20 characters")
    private String chequeNumber;

    @NotNull(message = "Scheduled date is required")
    private LocalDate scheduledDate;

    @NotNull(message = "Scheduled month is required")
    private LocalDate scheduledMonth;

    private LocalDate paymentDate;

    @NotNull(message = "Payment status is required")
    private Short paymentStatus;

    private boolean deleted;
    private LocalDateTime createdAt;
    private LocalDateTime deletedAt;
    private LocalDateTime modifiedAt;
    private Long createdBy;
    private Long deletedBy;
    private Long modifiedBy;
}

package com.cboard.rental.tenants.dto;

import java.time.LocalDateTime;

import lombok.Data;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import java.time.LocalDateTime;

@Data
public class TenantsDTO {

    private Long id;

    @NotBlank(message = "Full name is required")
    @Size(max = 100, message = "Full name cannot exceed 100 characters")
    private String fullName;

    @Size(max = 100, message = "Company name cannot exceed 100 characters")
    private String companyName;

    @NotBlank(message = "Phone is required")
    @Size(max = 15, message = "Phone cannot exceed 15 characters")
    private String phone;

    @Email(message = "Email should be valid")
    private String email;

    @NotBlank(message = "ID number is required")
    @Size(max = 20, message = "ID number cannot exceed 20 characters")
    private String idNo;

    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
package com.cboard.rental.tenants.entity;
import jakarta.persistence.*;
import lombok.Data;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Data
@Entity
@Table(name = "contracts")
public class Contract {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "tenant_id", nullable = false)
    private Tenants tenant;

    @Column(name = "property_id", nullable = false)
    private Long propertyId;

    @Column(name = "start_date", nullable = false)
    private LocalDate startDate;

    @Column(name = "end_date", nullable = false)
    private LocalDate endDate;

    @Column(name = "monthly_rent", nullable = false)
    private BigDecimal monthlyRent;

    @Column(name = "deposit_amount", nullable = false)
    private BigDecimal depositAmount;

    @Column(name = "payment_terms")
    private String paymentTerms;

    @Column(name = "contract_status", nullable = false)
    private String contractStatus;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
}
package com.cboard.rental.tenants.entity;
import jakarta.persistence.*;
import lombok.Data;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Data
@Entity
@Table(name = "payment_schedule")
public class PaymentSchedule {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "shd_id")
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "tenant_id", nullable = false)
    private Tenants tenant;

    @Column(name = "contract_id", nullable = false)
    private Long contractId;

    @Column(name = "property_id", nullable = false)
    private Long propertyId;

    @Column(name = "amount", precision = 13, scale = 3, nullable = false)
    private BigDecimal amount;

    @Column(name = "bank_id")
    private Short bankId;

    @Column(name = "cheque_number", length = 20)
    private String chequeNumber;

    @Column(name = "scheduled_date", nullable = false)
    private LocalDate scheduledDate;
    
    
    @Column(name = "status")
    private String status;  // Ensure this field is available and correctly named

    @Column(name = "scheduled_month", nullable = false)
    private LocalDate scheduledMonth;

    @Column(name = "payment_date")
    private LocalDate paymentDate;

    @Column(name = "payment_status", nullable = false)
    private Short paymentStatus;

    @Column(name = "deleted", nullable = false)
    private boolean deleted = false;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    @Column(name = "modified_at")
    private LocalDateTime modifiedAt;

    @Column(name = "created_by")
    private Long createdBy;

    @Column(name = "deleted_by")
    private Long deletedBy;

    @Column(name = "modified_by")
    private Long modifiedBy;
}
package com.cboard.rental.tenants.entity;
import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.DynamicUpdate;
import java.time.LocalDateTime;

@Data
@Entity
@Table(name = "tenants")
@DynamicUpdate
public class Tenants {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "full_name", nullable = false)
    private String fullName;

    @Column(name = "company_name")
    private String companyName;

    @Column(name = "phone", nullable = false)
    private String phone;

    @Column(name = "email")
    private String email;

    @Column(name = "id_no", unique = true, nullable = false)
    private String idNo;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
}
package com.cboard.rental.tenants.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

import com.cboard.rental.tenants.dto.ContractDTO;
import com.cboard.rental.tenants.entity.Contract;

@Mapper(componentModel = "spring")
public interface ContractMapper {
    ContractMapper INSTANCE = Mappers.getMapper(ContractMapper.class);
    
    @Mapping(source = "tenant.id", target = "tenantId")
    ContractDTO toDTO(Contract contract);
    
    @Mapping(source = "tenantId", target = "tenant.id")
    Contract toEntity(ContractDTO contractDTO);
}
package com.cboard.rental.tenants.mapper;

import com.cboard.rental.tenants.dto.PaymentScheduleDTO;
import com.cboard.rental.tenants.entity.PaymentSchedule;
import com.cboard.rental.tenants.entity.Tenants;
import com.cboard.rental.tenants.repository.TenantsRepository;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.List;

@Mapper(componentModel = "spring", uses = {TenantIdMapper.class})
public interface PaymentScheduleMapper {

    @Mapping(source = "tenant.id", target = "tenantId")
    PaymentScheduleDTO toDto(PaymentSchedule paymentSchedule);

    @Mapping(source = "tenantId", target = "tenant")
    PaymentSchedule toEntity(PaymentScheduleDTO paymentScheduleDTO);

    List<PaymentScheduleDTO> toDtoList(List<PaymentSchedule> paymentSchedules);
}

// Custom Mapper to resolve tenant by ID
@Component
class TenantIdMapper {
    
    @Autowired
    private TenantsRepository tenantsRepository;

    public Tenants mapTenantIdToTenant(Long tenantId) {
        return tenantId != null ? tenantsRepository.findById(tenantId).orElse(null) : null;
    }

    public Long mapTenantToTenantId(Tenants tenant) {
        return tenant != null ? tenant.getId() : null;
    }
}
package com.cboard.rental.tenants.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.factory.Mappers;
import com.cboard.rental.tenants.dto.TenantsDTO;
import com.cboard.rental.tenants.entity.Tenants;

@Mapper
public interface TenantsMapper {
    TenantsMapper INSTANCE = Mappers.getMapper(TenantsMapper.class);
    
    TenantsDTO toDTO(Tenants tenants);
    Tenants toEntity(TenantsDTO tenantsDTO);
}
package com.cboard.rental.tenants.repository;

import com.cboard.rental.tenants.entity.Contract;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ContractRepository extends JpaRepository<Contract, Long> {
    
    List<Contract> findByTenantIdAndPropertyId(Long tenantId, Long propertyId);
    List<Contract> findByTenantId(Long tenantId);
    List<Contract> findByPropertyId(Long propertyId);
    
}
package com.cboard.rental.tenants.repository;

import com.cboard.rental.tenants.entity.PaymentSchedule;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;


import java.time.LocalDate;
import java.util.List;

@Repository
public interface PaymentScheduleRepository extends JpaRepository<PaymentSchedule, Long> {
    // Custom query to find all payment schedules by tenant and contract
    List<PaymentSchedule> findByTenantIdAndContractId(Long tenantId, Long contractId);

    // Custom query to find payment schedules within a specific date range
    List<PaymentSchedule> findByScheduledDateBetween(LocalDate startDate, LocalDate endDate);
    
    @Query("SELECT p FROM PaymentSchedule p WHERE p.scheduledDate = :date AND p.status = 'DUE'")
    List<PaymentSchedule> findDuePayments(@Param("date") LocalDate date);

}package com.cboard.rental.tenants.repository;

import com.cboard.rental.tenants.entity.Tenants;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface TenantsRepository extends JpaRepository<Tenants, Long> {
    // Custom query methods can be added here if needed, e.g., find by email or phone
    Tenants findByIdNo(String idNo);
}
package com.cboard.rental.tenants.scheduler;

import com.cboard.rental.tenants.clients.MessagingServiceClient;
import com.cboard.rental.tenants.dto.DuePaymentEvent;
import com.cboard.rental.tenants.entity.PaymentSchedule;
import com.cboard.rental.tenants.repository.PaymentScheduleRepository;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.time.LocalDate;
import java.util.List;

/*@Component
public class DuePaymentScheduler {

    private final PaymentScheduleRepository paymentScheduleRepository;
    private final MessagingServiceClient messagingServiceClient;

    public DuePaymentScheduler(PaymentScheduleRepository paymentScheduleRepository, MessagingServiceClient messagingServiceClient) {
        this.paymentScheduleRepository = paymentScheduleRepository;
        this.messagingServiceClient = messagingServiceClient;
    }

    @Scheduled(cron = "0 0 0 * * *") // Runs daily at midnight
    public void publishDuePayments() {
        List<PaymentSchedule> duePayments = paymentScheduleRepository.findDuePayments(LocalDate.now());
        duePayments.forEach(payment -> {
           DuePaymentEvent event = new DuePaymentEvent(payment.getTenant().getId(), payment.getContractId(), payment.getAmount(), payment.getScheduledDate());
           messagingServiceClient.sendDuePaymentEvent(event);
        });
    }
}

        	//DuePaymentEvent event = new DuePaymentEvent(payment.getTenant().getId(), payment.getContractId(), payment.getAmount(), payment.getScheduledDate());
*/

@Component
public class DuePaymentScheduler {

    private final PaymentScheduleRepository paymentScheduleRepository;
    private final MessagingServiceClient messagingServiceClient;

    public DuePaymentScheduler(PaymentScheduleRepository paymentScheduleRepository, MessagingServiceClient messagingServiceClient) {
        this.paymentScheduleRepository = paymentScheduleRepository;
        this.messagingServiceClient = messagingServiceClient;
    }

    @Scheduled(cron = "0 0 0 * * *") // Runs daily at midnight
    public void publishDuePayments() {
        List<PaymentSchedule> duePayments = paymentScheduleRepository.findDuePayments(LocalDate.now());
        duePayments.forEach(payment -> {
        	System.out.println("Processing Due Payment: " + payment);
            DuePaymentEvent event = new DuePaymentEvent(payment.getTenant().getId(), payment.getContractId(), payment.getAmount(), payment.getScheduledDate());
            try {
                messagingServiceClient.sendDuePaymentEvent(event);
            } catch (Exception e) {
                // Log and consider retrying or adding to a dead-letter queue
                System.err.println("Failed to send due payment event for tenant ID: " + payment.getTenant().getId());
            }
        });
    }
}

package com.cboard.rental.tenants.service;

import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;

@Service
public class BillingProducerService {

    private static final String DUE_PAYMENT_TOPIC = "due-payment-topic";

    private final KafkaTemplate<String, Object> kafkaTemplate;

    public BillingProducerService(KafkaTemplate<String, Object> kafkaTemplate) {
        this.kafkaTemplate = kafkaTemplate;
    }

    public void sendMessage(Object message) {
        kafkaTemplate.send(DUE_PAYMENT_TOPIC, message);
    }
}
package com.cboard.rental.tenants.service;

import com.cboard.rental.tenants.clients.PropertyServiceClient;
import com.cboard.rental.tenants.config.ResourceNotFoundException;
import com.cboard.rental.tenants.dto.ContractDTO;
import com.cboard.rental.tenants.entity.Contract;
import com.cboard.rental.tenants.entity.Tenants;
import com.cboard.rental.tenants.mapper.ContractMapper;
import com.cboard.rental.tenants.repository.ContractRepository;
import com.cboard.rental.tenants.repository.TenantsRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class ContractService {

    @Autowired
    private ContractRepository contractRepository;

    @Autowired
    private TenantsRepository tenantsRepository;

    @Autowired
    private PropertyServiceClient propertyServiceClient;

    private final ContractMapper mapper = ContractMapper.INSTANCE;

    public ContractDTO createContract(ContractDTO contractDTO) {
        // Validate tenant
        Tenants tenant = tenantsRepository.findById(contractDTO.getTenantId())
                .orElseThrow(() -> new ResourceNotFoundException("Tenant", contractDTO.getTenantId()));

        // Validate property from property-service using Feign client
        Boolean propertyExists = propertyServiceClient.doesPropertyExist(contractDTO.getPropertyId());
        if (Boolean.FALSE.equals(propertyExists)) {
            throw new ResourceNotFoundException("Property", contractDTO.getPropertyId());
        }

        Contract contract = mapper.toEntity(contractDTO);
        contract.setTenant(tenant);
        contract.setCreatedAt(LocalDateTime.now());

        Contract savedContract = contractRepository.save(contract);
        return mapper.toDTO(savedContract);
    }

    public List<ContractDTO> getAllContracts(Long tenantId, Long propertyId) {
        List<Contract> contracts;

        if (tenantId != null && propertyId != null) {
            contracts = contractRepository.findByTenantIdAndPropertyId(tenantId, propertyId);
        } else if (tenantId != null) {
            contracts = contractRepository.findByTenantId(tenantId);
        } else if (propertyId != null) {
            contracts = contractRepository.findByPropertyId(propertyId);
        } else {
            contracts = contractRepository.findAll();
        }

        return contracts.stream()
                .map(mapper::toDTO)
                .collect(Collectors.toList());
    }



    public ContractDTO getContractById(Long id) {
        Contract contract = contractRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Contract", id));
        return mapper.toDTO(contract);
    }

    public List<ContractDTO> getContractsByTenantId(Long tenantId) {
        return contractRepository.findByTenantId(tenantId).stream()
                .map(mapper::toDTO)
                .collect(Collectors.toList());
    }

    public List<ContractDTO> getContractsByPropertyId(Long propertyId) {
        return contractRepository.findByPropertyId(propertyId).stream()
                .map(mapper::toDTO)
                .collect(Collectors.toList());
    }

    public ContractDTO updateContract(Long id, ContractDTO contractDTO) {
        Contract contract = contractRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Contract", id));

        // Update fields
        contract.setPropertyId(contractDTO.getPropertyId());
        contract.setStartDate(contractDTO.getStartDate());
        contract.setEndDate(contractDTO.getEndDate());
        contract.setMonthlyRent(contractDTO.getMonthlyRent());
        contract.setDepositAmount(contractDTO.getDepositAmount());
        contract.setPaymentTerms(contractDTO.getPaymentTerms());
        contract.setContractStatus(contractDTO.getContractStatus());
        contract.setUpdatedAt(LocalDateTime.now());

        Contract updatedContract = contractRepository.save(contract);
        return mapper.toDTO(updatedContract);
    }

    public void deleteContract(Long id) {
        if (!contractRepository.existsById(id)) {
            throw new ResourceNotFoundException("Contract", id);
        }
        contractRepository.deleteById(id);
    }
}
package com.cboard.rental.tenants.service;

import com.cboard.rental.tenants.dto.PaymentScheduleDTO;
import com.cboard.rental.tenants.entity.PaymentSchedule;
import com.cboard.rental.tenants.mapper.PaymentScheduleMapper;
import com.cboard.rental.tenants.repository.PaymentScheduleRepository;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class PaymentScheduleService {

    private final PaymentScheduleRepository repository;
    private final PaymentScheduleMapper mapper;

    @Autowired
    public PaymentScheduleService(PaymentScheduleRepository repository, PaymentScheduleMapper mapper) {
        this.repository = repository;
        this.mapper = mapper;
    }

    public PaymentScheduleDTO createPaymentSchedule(@Valid PaymentScheduleDTO dto) {
        PaymentSchedule paymentSchedule = mapper.toEntity(dto);
        PaymentSchedule savedPaymentSchedule = repository.save(paymentSchedule);
        return mapper.toDto(savedPaymentSchedule);
    }

    public PaymentScheduleDTO getPaymentScheduleById(Long id) {
        return repository.findById(id)
                .map(mapper::toDto)
                .orElseThrow(() -> new RuntimeException("Payment Schedule not found with id: " + id));
    }

    public List<PaymentScheduleDTO> getAllPaymentSchedules() {
        return mapper.toDtoList(repository.findAll());
    }

    public PaymentScheduleDTO updatePaymentSchedule(Long id, @Valid PaymentScheduleDTO dto) {
        if (!repository.existsById(id)) {
            throw new RuntimeException("Payment Schedule not found with id: " + id);
        }
        PaymentSchedule paymentSchedule = mapper.toEntity(dto);
        paymentSchedule.setId(id); // Ensure updating the correct entity
        PaymentSchedule updatedPaymentSchedule = repository.save(paymentSchedule);
        return mapper.toDto(updatedPaymentSchedule);
    }

    public void deletePaymentSchedule(Long id) {
        if (!repository.existsById(id)) {
            throw new RuntimeException("Payment Schedule not found with id: " + id);
        }
        repository.deleteById(id);
    }
}
package com.cboard.rental.tenants.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.cboard.rental.tenants.config.ResourceNotFoundException;
import com.cboard.rental.tenants.dto.TenantsDTO;
import com.cboard.rental.tenants.entity.Tenants;
import com.cboard.rental.tenants.mapper.TenantsMapper;
import com.cboard.rental.tenants.repository.TenantsRepository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class TenantsService {

    @Autowired
    private TenantsRepository tenantsRepository;

    private final TenantsMapper mapper = TenantsMapper.INSTANCE;

    public TenantsDTO createTenant(TenantsDTO tenantsDTO) {
        Tenants tenant = mapper.toEntity(tenantsDTO);
        tenant.setCreatedAt(LocalDateTime.now());
        Tenants savedTenant = tenantsRepository.save(tenant);
        return mapper.toDTO(savedTenant);
    }

    public List<TenantsDTO> getAllTenants() {
        return tenantsRepository.findAll().stream()
                .map(mapper::toDTO)
                .collect(Collectors.toList());
    }

    public TenantsDTO getTenantById(Long id) {
        Tenants tenant = tenantsRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Tenant", id));
        return mapper.toDTO(tenant);
    }

    public TenantsDTO updateTenant(Long id, TenantsDTO tenantsDTO) {
        Tenants tenant = tenantsRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Tenant", id));

        // Update tenant fields
        tenant.setFullName(tenantsDTO.getFullName());
        tenant.setCompanyName(tenantsDTO.getCompanyName());
        tenant.setPhone(tenantsDTO.getPhone());
        tenant.setEmail(tenantsDTO.getEmail());
        tenant.setIdNo(tenantsDTO.getIdNo());
        tenant.setUpdatedAt(LocalDateTime.now());

        Tenants updatedTenant = tenantsRepository.save(tenant);
        return mapper.toDTO(updatedTenant);
    }

    public void deleteTenant(Long id) {
        if (!tenantsRepository.existsById(id)) {
            throw new ResourceNotFoundException("Tenant", id);
        }
        tenantsRepository.deleteById(id);
    }
}
package com.cboard.rental.tenants;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
//import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
//@EnableDiscoveryClient
@EnableFeignClients
public class TenantsServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(TenantsServiceApplication.class, args);
    }
}spring.application.name=tenants-service

# Server Port
server.port=8093

# Datasource Configuration
spring.datasource.url=jdbc:postgresql://127.0.0.1:5432/jsb_cbord_dbtenants
spring.datasource.username=postgres
spring.datasource.password=postgres

# JPA and Hibernate Configuration
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.ddl-auto=update

eureka.client.enabled=false

# Eureka Client Configuration
# eureka.client.service-url.defaultZone=http://localhost:8761/eureka/
# eureka.client.register-with-eureka=true
# eureka.client.fetch-registry=true

# Override Bean Definitions if Necessary
spring.main.allow-bean-definition-overriding=true

# Logging Level for Security (Debugging Purposes)
logging.level.org.springframework.security=DEBUG

# JWT Configuration
jwt.secret=4k3AXsvddC06fvwLMtxg/jx99/kc24dV/O0Cybx3gP8=
jwt.expiration=86400000

# SpringDoc OpenAPI Configuration for Swagger
springdoc.api-docs.path=/v3/api-docs
springdoc.swagger-ui.path=/swagger-ui.html


logging.level.root=ERROR
org.springframework.security = ERROR


#spring.jpa.show-sql=true
#spring.jpa.properties.hibernate.format_sql=true
